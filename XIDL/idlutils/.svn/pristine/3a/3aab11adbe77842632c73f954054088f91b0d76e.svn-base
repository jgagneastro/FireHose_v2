<define-container fchange>
%body
</define-container>
<define-container td-body>
<td %attributes><fchange>%body</fchange></td>
</define-container>
<define-container td-para>
<td valign="top" align="left" %attributes><fchange>%body</fchange></td>
</define-container>
<define-container td-l>
<tr><td-body valign="middle" align="right" width="100"><a %attributes>%body</a></td-body>
</define-container>
<define-container td-r>
<td-body valign="middle" align="left" %attributes>%body</td-body></tr>
</define-container>
<define-container new-im><img src="images/new.gif" alt="New!" %attributes> (new %body)</define-container>
<define-container updated-im><img src="images/updated.gif" alt="Updated!" %attributes> (updated %body)</define-container>
<define-container download-im><img src="images/download.gif" alt="Download!" %attributes></define-container>
<define-container entry>
<hr>
<p><b><font size="+2"><a name="%0">%0</a></font></b><font size="+1"> - %1</font></p>
%body
</define-container>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!--
     Copyright (c) 1997-2000 Craig B. Markwardt
     Author:   Craig Markwardt (craigm@cow.physics.wisc.edu)
     Modified: 2005-07-23 13:22:04.
     Generated from ``fitqa.wml'' via WML 2.0.9 (18-Oct-2002).
               by Craig Markwardt (craigm@cow.physics.wisc.edu)
               on 2005-07-23 13:22:11.

     DO NOT EDIT THIS FILE DIRECTLY! INSTEAD EDIT ``fitqa.wml''.
-->
<meta name="Copyright" content="1997-2000 Craig B. Markwardt">
<meta name="Author"    content="Craig Markwardt, craigm@cow.physics.wisc.edu">
<meta name="Generator" content="WML 2.0.9 (18-Oct-2002)">
<meta name="Modified"  content="2005-07-23 13:22:04">
<title>%body</title>
<define-container title>
</define-container>
</head>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EF" VLINK="#55188A" ALINK="#FF0000" LANG="EN">
<h1>%body</h1>
<br><br><hr align="center" noshade><br>

<fchange>
<title>MPFIT Frequently Asked Questions</title>
<p><b><font size="+2"><a name="download">Which MPFIT Files Should I Download and Use?</a>
</font></b></p>
<p>The easiest solution is to download the entire set of routines as
either a <a href="down/mpfit.zip">ZIP file</a> or a <a
href="down/mpfit.tar.gz">gzipped TAR file</a>, and then extract them
in your IDL path. However it is possible to selectively download what
you need. Bear in mind that you will always need <a
href="down/mpfit.pro">MPFIT.PRO</a> which is the main fitting
engine.</p>
<p><b>For standard fitting of 1D curves</b>, where the model is a
compiled function, download <a
href="down/mpfitfun.pro">MPFITFUN.PRO</a> and <a
href="down/mpfit.pro">MPFIT.PRO</a>. For specialized peak fitting,
use <a href="down/mpfitpeak.pro">MPFITPEAK.PRO</a> in combination with
these two.</p>
<p><b>For fitting of 2D images or surfaces</b>, download <a
href="down/mpfit2dfun.pro">MPFIT2DFUN.PRO</a> and <a
href="down/mpfit.pro">MPFIT.PRO</a>. For peak fitting, use <a
href="down/mpfit2dpeak.pro">MPFIT2DPEAK.PRO</a> in combination with
these two.</p>
<p><b>For a drop-in replacement for the IDL-supplied CURVEFIT</b> in legacy
code, use <a href="down/mpcurvefit.pro">MPCURVEFIT.PRO</a> along with
<a href="down/mpfit.pro">MPFIT.PRO</a>.</p>
<p><b>For cases where you don't have a precompiled function</b>,
either at the command line on within your program, you can use an IDL
expression. Download <a href="down/mpfitexpr.pro">MPFITEXPR.PRO</a>
and <a href="down/mpfit.pro">MPFIT.PRO</a>.</p>
<p><b><font size="+2"><a name="model">How can I get the best-fit model?</a>
</font></b></p>
<p>All of the basic functions in the library return the best-fit model
function using the keyword YFIT. Simply pass a named variable with
this keyword and upon return the best-fit model will be in that
variable.</p>
<p>If you change the parameter values manually, it is still simple to
recompute the model function. It differs, depending on what type of
model you are fitting:</p>
<div align="center"><table border="0" summary="">
<tr><td><tt>yfit = model(x, p)</tt></td><td>1D Model named <tt>model</tt></td></tr>
<tr><td><tt>zfit = model(x, y, p)</tt></td><td>2D Model named <tt>model</tt></td></tr>
<tr><td><tt>yfit = MPEVALEXPR(expr, x, p)</tt></td><td>Expression named <tt>expr</tt></td></tr>
</table></div>
<p>Here, <tt>p</tt> is assumed to be the parameter set.</p>
<p><b><font size="+2"><a name="image">How do I fit a 2D image?</a>
</font></b></p>
<p>The simplest answer is to use the <a
href="down/mpfit2dfun.pro">MPFIT2DFUN.PRO</a> function. You supply
the image, the X and Y labels for each pixel, and a 2D model
function.</p>
<p><b><font size="+2"><a name="multivar">Can I fit a function of several variables?</a>
</font></b></p>
<p>This is a question when you are fitting a function of several
independent variables, such as this:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>y = f(x0,x1,x2, ...; p0, p1, p2, ...)</i><br>
<br>
where the <i>xi</i> are the independent variables and the <i>pi</i>
are fitting parameters.</p>
<p>Most of the MPFIT functions do not care how many independent
variables there are. In fact, the main fitting routine MPFIT does not
accept any independent variables at all! Instead, they are considered
to be implicit to the problem. Functions like MPFITFUN do accept an
independent variable called X. [ Since MPFIT itself doesn't deal with
the independent variables, MPFITFUN creates a common block with that
information so that the model function can gain access to it. ] </p>
<p>Therefore, if you are using plain MPFIT to do your fitting, then
you have the freedom to construct your model in any way you
please.</p>
<p>If you are using MPFITFUN or MPFIT2DFUN, then your model should
still be a function of a single variable X, and you should pass a
single set of independent variables called X to the fitting routine.
However, X can be arbitrarily complicated, so you can have it be a 2D
array, the first row containing "x0" values, the second containing
"x1", and so on. Thus the burden falls to your IDL model function to
decode the contents of X. I recommend the 2D array approach, but you
can also simply concatenate the variables in a 1D vector, or pass them
by COMMON block (not recommended).</p>
<p>The array approach I am advocating would be something like this:</p>
<tt>p = mpfitfun([x0, x1, x2], y, yerr, pstart, ...)</tt>
<p>This creates a new "X" variable which is the array concatenation of
all of your independent variables. Then the burden would be upon your
user function to extract the relevant quantities from this array.</p>
<p><b><font size="+2"><a name="help">Help! I can't get my fitting to work!</a>
</font></b></p>
<p>Generally speaking, this is not something I can help with. I am
probably not an expert in your field, and I am definitely not an
expert in optimization. However, I think there are a few very important
things that you must do.</p>
<p>First, you must make sure that the problem is well defined. Make
sure that you know exactly what function you plan on fitting. The
MPFIT functions are not psychic; they can't figure out how to solve
your problem for you.</p>
<p>I see quite a few people who can't get their model functions right.
The best kind of model function is self-contained, not depending on
any outside data or common blocks. Be sure that your model function
works by itself before throwing MPFIT into the mix. It is very
difficult to debug the problem when the added layer of MPFIT is
disguising everything. Be aware of domain problems. For example, if
you will be taking the square root of a parameter, you had better
constrain it to be positive.</p>
<p>Finally, and this can't be stressed enough, it is crucial to
estimate the starting parameters as best you can. Initializing the
parameters to all zeroes is actually the <i>worst</i> thing you can
do, since then the problem becomes scale-less, and MPFIT has a much
harder time deciding what to do.</p>
<p><b><font size="+2"><a name="deriv">Do I need to compute derivatives?</a>
</font></b></p>
<p>The short answer is, probably not. I have found that in most cases
the automatic finite difference technique used by MPFIT is sufficient.
Computing the derivatives explicitly seems to slow things down, and
can even make a worse final solution. My suggestion is to try it
first without computing the derivatives, and them implement
derivatives as needed (and the AUTODERIVATIVE=0 keyword).</p>
<p>However, see the caveats <a href="#parstep">below</a>.</p>
<p><b><font size="+2"><a name="widget">How can I embed MPFIT-style fitting in a widget application?</a>
</font></b></p>
<p> My belief is that the best solution is to use the ITERPROC
feature, which in turn would call WIDGET_EVENT manually to dispatch
events. Rob Dimeo has successfully integrated this approach into his
dedicated peak fitting program named <a
href="http://www.ncnr.nist.gov/staff/dimeo/panweb/pan.html">PAN</a>.
PAN is the winner of an honorable mention the recent IDL <a
href="http://www.rsinc.com/codebank/winners.asp">programming
contest</a>. Source code is available (uses objects). Nice job, Rob!
Here is a small screenshot:</p>
<div align="center">
<p><a href="http://www.ncnr.nist.gov/staff/dimeo/panweb/covergr.png"><img src="pan-small.png" alt="Small screen shot of Dimeo's PAN"></a></p>
<p>Small screen shot of <a href="http://www.ncnr.nist.gov/staff/dimeo/panweb/pan.html">PAN</a></p>
</div>
<p><b><font size="+2"><a name="noerrcheck">Why does MPFIT just return my parameters without fitting? / How do I check for processing errors?</a>
</font></b></p>
<p>Users occcasional report that MPFIT, or one of its drivers, return
without fitting any of the parameters. This is usually an indication
that MPFIT discovered an error in the user-specified parameters and
returned immediately.</p>
<p>Users should check the values of the STATUS and ERRMSG keywords
when MPFIT returns. If STATUS is less than or equal to 0, then a
processing error has occurred. A more detailed description of the
problem can be found by consulting the ERRMSG keyword.</p>
<p>A simple example of error checking using STATUS and ERRMSG might be:</p>
<pre>
  p = MPFITFUN(x, y, dy, p0, STATUS=status, ERRMSG=errmsg)
  if status LE 0 then message, errmsg
</pre>
<p>Of course, more sophisticated error handling approaches can be
implemented as needed.</p>
<p><b><font size="+2"><a name="parstep">Why does MPFIT not converge properly?</a>
</font></b></p>
<p>For certain problem sets, MPFIT will not converge to the "optimal"
solution. It may seem obvious to you that there is a better solution,
but MPFIT does not find it. Why could this be?</p>
<p>Be sure you are <a href="#noerrcheck">checking for error
conditions</a>. MPFIT may be indicating an error condition which
prematurely terminates the fit.</p>
<p>MPFIT normally uses a finite difference approximation to estimate
derivatives. This means that it varies each parameter by a small
amount, and measures the corresponding variation in the chi-square
value. However, if your data or model are discretized for some reason
then this approximation can fail, which then causes the fit not to
converge. You should check for: <ul>
<li><b>Automatically-selected step size too small.</b> In some cases,
the automatically-selected step sized used to compute derivatives is
too small. This usually happens when the dynamic range of the
parameter is very small compared to the absolute value. Solution: set
the step size manually with PARINFO.STEP or .RELSTEP, to be small
enough to resolve the variations in your fitting function. Another
solution is to re-write your model function to remove large constant
offsets from parameters.</li>
<li><b>Discretized parameters.</b>  Example: a tabulated model, which is
evaluated on a discrete grid of parameters. Solution: Interpolate the
table smoothly between parameter values; set PARINFO.STEP or .RELSTEP
values to be comparable to the grid spacing.</li>
<li><b>Discontinuous functions.</b>  Example: use of the ABS() function, or
any function which has a discontinous derivative. Solution: use
analytical derivatives; or use a smoother approximation to your
discontinuous function.</li>
<li><b>Undersampled data.</b> Example: fitting of undersampled peaks.
For example, consider data sampled with a grid spacing of 1 unit,
which contains a peak whose ideal full-width at half-max is 0.5 unit.
Since this peak is undersampled, the small parameter variations
attempted by MPFIT may have no measureable effect. Solution: get data
with finer sampling; adjust PARINFO.STEP or .RELSTEP to be comparable
to the grid spacing.</li> </ul>
<p>Also, beware that PARINFO.RELSTEP will not work if the parameter
value is zero. Generally speaking, all starting parameter values
should be non-zero.</p>
<p>Following along those lines, it's also worth checking what the
<b>dynamic range</b> of your parameters is. For example, if you are
fitting a model of 'p(0)+p(1)*x' where p(0) is 1 and p(1) is 1d-12,
then the fitting won't do very well. There are matrix operations
inside of MPFIT that may lose precision if there is a large dynamic
range in parameter values. It's better to absorb the 1d-12 factor
into the fitting function, so that all of the parameters are of
equivalent magnitude.</p>
<p>Finally, beware that if your chi-square function has <b>local
minima</b> then MPFIT may become irretrievably stuck. MPFIT is not a
global optimizer.</p>
</fchange>

<br><hr align="center" noshade>
<font size="-2"><i>Copyright &copy; 1997-2001 Craig B. Markwardt<br>
Last Modified on 2005-07-23 13:22:11 by Craig Markwardt<br>
</i></font><br>
</body>
</html>

