;+ 
; NAME:
; tauweighting
;    Version 1.0
;
; PURPOSE:
;   
;
; CALLING SEQUENCE:
;   
;  
;
; INPUTS: abslinlist - text file list of all .fit files generated by
;                      findlin.pro.  Should include path up to the
;                      directory containing these .fit files
;                      (hereafter directory name is abslin).  Files
;                      should be organized:
;                      /<SDSSPATH>/DR7_QSO/abslin/
;                      EXAMPLE: /Users/mkao/Work/SDSS/DR7_QSO/abslin/spSpec-*-.fit
;
; RETURNS: 
;
; OUTPUTS: civfil - .fit file of all CIV candidate systems flagged as DEFINITE,
;                   GOOD, MAYBE
;          badcivfil - .fit file of all CIV candidate systems flagged
;                      as BAD
;
; OPTIONAL KEYWORDS:
;   TOL - Set maximum that 
;
; OPTIONAL OUTPUTS:
;
; COMMENTS: To be called after sdss_civsearch.pro.  Can input civfil
;           into sdss_fixciv.pro 
;
; EXAMPLES:
;   sdss_chkciv, x, maskid, expsr
;
;
; PROCEDURES/FUNCTIONS CALLED:
;
; REVISION HISTORY:
;   10 June 2011, Written by MMK
;   
;-
;------------------------------------------------------------------------------


pro tauweighting, abslinlist, TOL=tol, BUCKETS=buckets, ITER=iter, DEBUG=debug
  
  IF NOT KEYWORD_SET(tol)      THEN tol = 0.0005
  IF NOT KEYWORD_SET(buckets)  THEN buckets = 3.0
  IF NOT KEYWORD_SET(iter)     THEN iter = 6
  clr = getcolor(/load)
  
  READCOL, abslinlist, abslinarr, format='A'
  abslinarr = GETENV('SDSSPATH') +'/DR7_QSO/'+ abslinarr[*]
  size = size(abslinarr)

  FOR i=0, size[1]-1 DO BEGIN
     abslin = xmrdfits(abslinarr[i], 1, hdr)
     abslinparts = STRSPLIT(abslinarr[i], '/', /EXTRACT)
     outabslin = GETENV('SDSSPATH') + '/DR7_QSO/abslincent/1d_26/'+abslinparts[7]+   $
                 '/'+abslinparts[8]+'/'+abslinparts[9]
     test = file_search(outabslin,count=ntest)
     IF ntest EQ 0 THEN spawn,'mkdir -p '+GETENV('SDSSPATH')+'/DR7_QSO/abslincent/1d_26/' $
                              + abslinparts[7]+'/'+abslinparts[8]+'/'

     IF abslin.ncent GT 0 THEN BEGIN
        filsdss =  GETENV('SDSSPATH')+'/DR7_QSO/'+abslin.sdss_obs[0]
        parse_sdss, filsdss, flux, wave, ZQSO=zqso, IVAR=ivar, NPIX=npix, $
                    HEAD=sdss_head, SIG=sig
        ;;;; Make wave and continuum arrays that subdivide original
        ;;;; arrays by buckets--gives option of having finer
        ;;;; resolution if needed.  So far, it seems that buckets = 1.0
        ;;;; (ie no subdivision) works just fine.
        n = npix*LONG(buckets)
        dloglambda = sxpar(sdss_head, "CD1_1") / buckets
        wavesplit = 10^(  sxpar(sdss_head,"CRVAL1")  +  findgen(n)*dloglambda  ) 

        
        ;;;; Set normalized continuum
        IF abslin.cflg EQ 0 THEN BEGIN
           conti =  abslin.cspline[0:abslin.npix-1]
           contisplit = DBLARR(n)
           fluxsplit  = DBLARR(n)
           step = LINDGEN( LONG(buckets) )
           FOR k=0, npix-1 DO BEGIN
              fluxsplit[step+k*LONG(buckets)] = flux[k]
              contisplit[step+k*LONG(buckets)] = conti[k]
           ENDFOR  
           norm = fluxsplit[*] / (contisplit[*] ) 
        ENDIF
        IF abslin.cflg EQ 1 THEN BEGIN
           conti =  abslin.ceigen[0:abslin.npix-1]
           contisplit = DBLARR(n)
           fluxsplit  = DBLARR(n) 
           step = LINDGEN( LONG(buckets) )
           FOR k=0, npix-1 DO BEGIN
              fluxsplit[step+k*LONG(buckets)] = flux[k]
              contisplit[step+k*LONG(buckets)] = conti[k]
           ENDFOR  
           norm = fluxsplit[*] / (contisplit[*] ) 
        ENDIF 
        IF abslin.cflg NE 1 AND abslin.cflg NE 0 THEN $
           print, "tauweighting.pro error: Not a valid cflg", STOP


        targetwave = abslin.centroid[0:abslin.ncent-1]    ;;;; wavelengths of interest
        newcentroids = DBLARR(abslin.ncent)               ;;;; new centroids

      
        FOR targnum = 0, abslin.ncent-1 DO BEGIN
           ;;;; Find where to start looking at flux.  If targetwave
           ;;;; does not correspond to an exact wavesplit element, then
           ;;;; find the indices with wavelengths on either side of
           ;;;; wavelength of interest.  Then set starting index as
           ;;;; the index that corresponds to the index whose
           ;;;; wavlength is closest to the wavelength of interest.
           index = WHERE(    targetwave[targnum] LT wavesplit+0.001 AND   $
                             targetwave[targnum] GT wavesplit-0.001       )
           IF index EQ -1 THEN BEGIN 
              dist = MIN (  ABS(  wavesplit - targetwave[targnum]  ), index)
           ENDIF
           
           ;;;; Now make a matrix that brackets with successively
           ;;;; larger ranges this starting wavelength.  Check to make
           ;;;; sure that the bracketed indices do not go beyond the
           ;;;; indices of the wavesplit array
           bracket = REPLICATE(!VALUES.F_NAN, 2, iter)
           FOR niter = 0, iter-1 DO BEGIN
              low  = index[0] - (niter+1)
              high = index[0] + (niter+1)
              IF low GE 0 AND high LE size(wavesplit,/DIM)-1 THEN BEGIN
                 bracket[0,niter] = low
                 bracket[1,niter] = high
              ENDIF
              IF low LT 0 OR high GT size(wavesplit,/DIM)-1 THEN BREAK
           ENDFOR
           keep = WHERE(  FINITE(bracket), nkeep)
           IF nkeep NE 0 THEN BEGIN
              bracket = reform( bracket[keep], 2, nkeep/2  )
           ENDIF
           sizebracket = size(bracket, /DIM)



           ;;;; Checking that bracket has dimensions greater than 0.
           ;;;; Otherwise, skip to the bottom and set newcentroids[targnum]=targetwave
           IF nkeep NE 0 THEN BEGIN
              ;;;; Now make a matrix that fills in all indices to try out
              ;;;; bfrom low bracket to high bracket.  It will look like
              ;;;; a pyramid.  For instance, if the index that is closest
              ;;;; to the original centroid is 3850, then indices will
              ;;;; look like:   
              ;;;; NAN     NAN     3849     3850     3851     NAN     NAN
              ;;;; NAN     3848    3849     3850     3851     3852    NAN
              ;;;; 3846    3847    3849     3850     3851     3852    3853
              indinit = bracket[0,sizebracket[1]-1] +   $
                        LINDGEN(bracket[1,sizebracket[1]-1] - bracket[0,sizebracket[1]-1]+1)
              indices = REPLICATE(!VALUES.F_NAN, $
                                  size(indinit, /DIM), sizebracket[1] )
              FOR k=0, sizebracket[1]-1 DO BEGIN
                 lowind  = WHERE(bracket[0,k] EQ indinit)
                 highind = WHERE(bracket[1,k] EQ indinit)
                 indices[lowind:highind,k] = indinit[lowind:highind]
              ENDFOR
              reject = WHERE( FINITE(indices, /NAN) )
              keep = WHERE( FINITE(indices) )
              indices[reject] = 0     ;;;; OK to set NAN indices to 0 b/c prevents 
                                      ;;;; indexing error later.  Will
                                      ;;;; not be erroneously included
                                      ;;;; in average lambda because
                                      ;;;; the weight of these
                                      ;;;; elements is also set to 0
              
              ;;;; Create weighting matrix
              w = EXP(1. / norm[indices]) 
              w[reject] = 0.0
              

              ;;;; Potential centroids
              cent = DBLARR(sizebracket[1])            
              FOR niter = 0, sizebracket[1]-1 DO BEGIN
                 cent[niter] = TOTAL(wavesplit[indices[0:sizebracket[1]*2,niter] ] *    $
                                     w[indices[0:sizebracket[1]*2,niter]], /NAN  ) /    $
                               TOTAL(w[indices[0:sizebracket[1]*2,niter]], /NAN)
              ENDFOR
              

              ;;; Now find where the difference between successive
              ;;; potential centroids is minimized.  Must also meet
              ;;; criteria where the difference between two successive
              ;;; centroids is LE a given tolerance, tol
              tmpcent = [ targetwave[targnum], cent[0:niter-2] ]
              diff = ABS( cent-tmpcent )
              mindiff = MIN(diff, centind)
              
              IF mindiff LE tol THEN BEGIN
                 centroid = cent[centind]
                 bounds = [ bracket[0, centind],  bracket[1,centind] ]
                 print, "Buckets used = ", bracket[1,centind]-bracket[0,centind] + 1
              ENDIF
              IF mindiff GT tol THEN BEGIN
                 stop, "No centroid found"
                 centroid = targetwave
              ENDIF

              abslin.centroid[targnum] = centroid    ;;;; Update stored centroid with new
              newcentroids[targnum]    = centroid    ;;;; For bookkeeping purposes
              

           ;;;; %%%%%%%%%%%%%  DEBUG PLOTTING  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ;;;; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
              IF KEYWORD_SET(debug) THEN BEGIN  
                 
                 print, "bracket= ", bracket
                 print, "centroids= ", cent
                 print, " difference= ",diff
                 
                 plotarray = bracket[0]-10*LONG(buckets) + LINDGEN(20*LONG(buckets))
                 plot, wavesplit[plotarray], norm[plotarray], psym=10, color=clr.black,$
                       background=clr.white, yrange=[-1.,2], xstyle=1, ystyle=1
                 oplot, targetwave[targnum]*[1.,1],  [-3,3.], color=clr.black,     $
                        linestyle=1, thick=1.2
                 oplot, centroid*[1.,1],             [-3,3.], color=clr.magenta,   $
                        linestyle=2, thick=1.2
                 oplot, wavesplit[bounds[0]]*[1.,1], [-3,3.], color=clr.blue,      $
                        linestyle=1, thick=1.2
                 oplot, wavesplit[bounds[1]]*[1.,1], [-3,3.], color=clr.blue,      $
                        linestyle=1, thick=1.2
                 oplot, wavesplit[plotarray], wavesplit[plotarray]*0.0+1.0, psym=10, color=clr.green
                 stop
              ENDIF
           ;;;; %%%%%%%%%%%%% END DEBUG PLOTTING  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
           ;;;; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


           ENDIF   ;;;; Finish checking that bracket has dimensions greater than 0
           ENDFOR  ;;;; Finish going through each target wavelength (targnum)
        MWRFITS, abslin, outabslin, /CREATE
 
        
        ;;;; PPPPPPPPPPPPP  DEBUG PRINTING  PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
        ;;;; PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
        IF KEYWORD_SET(debug) THEN BEGIN
           print, "Original Centroids: ", targetwave
           print, "New Centroids: ", newcentroids
        END
        ;;;; PPPPPPPPPPPPP END DEBUG PRINTING PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
        ;;;; PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
        
     ENDIF  ;;;; Finish going through each abslin file that has target wavlengths (i)
  ENDFOR
          
end
  
